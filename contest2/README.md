Здесь я приведу условия самых интересных задач

## Задача E-Очередь с минимумом

*Ограничение времени:*	2 с

*Ограничение памяти:*	256 M

Напишите свой класс MinQueue, используя шаблонный класс pair и stack из STL.

Напишите программу, содержащую описание очереди с минимумом и моделирующую работу очереди с минимумом, реализовав все указанные здесь методы. 
Возможные команды для программы: 

* `enqueue` n	Добавить в очередь число n (1 ≤ n ≤ 10^9) (значение n задается после команды). Программа должна вывести ok. 

* `dequeue` Удалить из очереди последний элемент. Программа должна вывести его значение. 

* `front`	Программа должна вывести значение первого элемента, не удаляя его из очереди. 

* `size`	Программа должна вывести количество элементов в очереди. 

* `clear`	Программа должна очистить очередь и вывести ok. 

* `min`	Программа должна вывести минимум в очереди, не удаляя его из очереди. 

Перед исполнением операций `front`, `dequeue` и `min` программа должна проверять, содержится ли в очереди хотя бы один элемент. Если во входных данных встречается операция front, dequeue или min, и при этом очередь пуста, то необходимо сгенерировать исключение MinQueueEmptyException и вывести error.

#### *Формат входных данных*

В первой строке входных данных записано единственное число M (1 ≤ M ≤ 200000) — количество команд. 
В следующих М строках дано по одной команде из тех, что идут выше.

#### *Формат результата*

Для каждой команды выведите одну строчку — результат ее выполнения.

------

## Задача N-Коммерческий калькулятор

*Ограничение времени:*	2 с

*Ограничение памяти:*	256 M

Фирма OISAC выпустила новую версию калькулятора. Этот калькулятор берет с пользователя деньги за совершаемые арифметические операции. Стоимость каждой операции в долларах равна 5% от числа, которое является результатом операции.

На этом калькуляторе требуется вычислить сумму N натуральных чисел (числа известны). Нетрудно заметить, что от того, в каком порядке мы будем складывать эти числа, иногда зависит, в какую сумму денег нам обойдется вычисление суммы чисел (тем самым, оказывается нарушен классический принцип "от перестановки мест слагаемых сумма не меняется").

Например, пусть нам нужно сложить числа 10, 11, 12 и 13. Тогда если мы сначала сложим 10 и 11 (это обойдется нам в $1.05), потом результат - с 12 ($1.65), и затем - с 13 ($2.3), то всего мы заплатим $ 5, если же сначала отдельно сложить 10 и 11 ($1.05), потом - 12 и 13 ($1.25) и, наконец, сложить между собой два полученных числа ($2.3), то в итоге мы заплатим лишь $ 4.6.

Напишите программу, используя `priority_queue`, которая будет определять, за какую минимальную сумму денег можно найти сумму данных N чисел.

#### *Формат входных данных*

Во входном файле записано число N (2 ≤ N ≤ 105). Далее идет N натуральных чисел, которые нужно сложить, каждое из них не превышает 10000.

#### *Формат результата*

В выходной файл выведите, сколько денег нам потребуется на нахождение суммы этих N чисел. Результат должен быть выведен с двумя знаками после десятичной точки.

-----
## Задача O-Медианный сет

*Ограничение времени:*	2 с

*Ограничение памяти:*	256 M

Реализуйте структуру данных для хранения различных целых чисел, которая поддерживает 4 операции:

* `add` x — добавить в структуру элемент x,

* `min` — извлечь из структуры минимальный элемент,

* `max` — извлечь из структуры максимальный элемент,

* `mid` — извлечь из структуры медианный элемент 

(если в структуре хранится n элементов `a0 < a1 < ... < an - 1`, то процедура извлекает элемент `a[(n - 1) / 2]`).

#### *Формат входных данных*

В первой строке входных данных находится число n (1 ≤ n ≤ 105). В следующих n строчках находятся описанные выше операции:

`add` x (1 ≤ x ≤ 109)

`min`

`max`

`mid`

*Все значения x во входных данных различны.*

#### *Формат результата*

На каждый запрос `min`, `max` и `mid` выведите значение извлечённого элемента.

----

## Задача P-Кэширование значений функции

*Ограничение времени:*	2 с

*Ограничение памяти:*	256 M

Вы на грани вылета из института. И неудивительно -- на французский Вы не ходили, по курсу теории групп и представлений Вы не захотели получать трояк и пошли на пересдачу, на которую не пришли, так как вместо этого пошли с подругой на фильм "Очарованная". Далее физкультура и ещё матан, теормех, ... Эх!!!

>Возможно, к преподавателю по французскому Вы найдете подход. У него есть активно посещаемый сайт, посвященный парному обучению иностранным языкам. И сайт этот в последнее время жутко тормозит -- слишком много пользователей в онлайне занимаюся парным обучением. Преподаватель Вам сказал, что если Вы "ускорите работу сайта", то, возможно, он сможет пойти Вам навстречу.

После некоторого изучения кода, Вы поняли, что слишком часто происходят обращения к базе данных, а именно, к таблице пользователей. Смысла в этом особого нет, поскольку набор посетителей сайта в каждый момент времени ограничен, и профайлы пользователей можно для быстрого доступа хранить в памяти, пока они осуществляют навигацию по сайту.

Нужно просто написать кэширующую версию функции `get_user(int user_id)`, которая возвращает профайлы пользователей, хранящиеся в базе данных.

Логику кэширования Вы придумали следующую. Пусть размер кэша равен M. Тогда функция с кэшированием значений должна хранить список закэшированных профайлов пользователей (будем профайлы пользователей называть просто пользователями). Размер списка не более M. Он конструируется по следующему принципу.

Когда функция вызывается с некоторым аргументом `user_id` необходимо проверить, есть ли пользователь с таким идентификатором в списке, и если есть, вернуть закэшированный профайл, предварительно переместив его в самое начало списка. Если такого пользователя нет, то нужно обратиться к базе данных и поместить пользователя в начало списка. Если размер списка стал больше M (а именно, M + 1), необходимо удалить из него последний элемент.

Таким образом, в списке всегда будут храниться закэшированные ответы для последних M использованных уникальных значений аргумента функции.

Вы хотите изучить, как меняется польза от кэширования в зависимости от значения M на последовательности реальных данных.

Надо отметить, что просто бежать по списку при поиска элемента может оказаться неээфективным. Нужно как-то быстро научится находить элемент в списке, если он там есть.

Для решения этой задачи используйте ассоциативный контейнер и очередь с приоритетами.

#### *Формат входных данных*

Первая строка входа содержит размер кэша M, 0 < M ≤ 500000. Затем идёт последовательность целых чисел из диапазона [0,  20000000], разделённых пробельными символами. Количество чисел не больше 500000.

#### *Формат результата*

Для каждого введённого числа необходимо вывести 0, если использовалось закэшированное значение, а иначе -- 1. Другими словами, для каждого введенного числа нужно выводить 1, если среди последних M уникальных чисел его нет, а если есть -- выводить 0. Цифры разделяйте пробелом.


| Входные данные   |  Результат |
|------------------|:-------------:|
| 10
1 2 3 4 5          |  1 1 1 1 1 |
5
1 2 3 1 4 5 6 7 2 5 1 3 2 | 1 1 1 0 1 1 1 1 1 0 1 1 0 |

